<html>
	<head>
		<style>
			.link {
				stroke: #333;
				stroke-opacity: 0.8;
				stroke-width: 0.5px;
			}

			.link.active {
				stroke: #c33;
				stroke-opactiy: 1.0;
				stroke-width: 2px;
			}

			.node {
				stroke: #000;
				stroke-width: 0px;
			}

			.node.active {
				stroke: #000;
				stroke-width: 2px;
				fill: #c33;
			}
		</style>
		<script src="https://d3js.org/d3.v4.min.js"></script>
		<script src="https://d3js.org/d3-color.v1.min.js"></script>
		<script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
		<script src="https://d3js.org/d3-ease.v1.min.js"></script>
		<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
		<script src="https://d3js.org/d3-selection.v1.min.js"></script>
		<script src="https://d3js.org/d3-timer.v1.min.js"></script>
		<script src="https://d3js.org/d3-transition.v1.min.js"></script>
		<script src="https://d3js.org/d3-drag.v1.min.js"></script>
		<script src="https://d3js.org/d3-zoom.v1.min.js"></script>
		<script src="config.js"></script>
	</head>
	<body>
		<script>
			function main()
			{
				if (window.location.hash.length == 0) {
					alert("no dataset selected");
					return;
				}

				var dataset_name = window.location.hash.substr(1);
				if (! config["datasets"].includes(dataset_name)) {
					alert("dataset doesn't exist");
				}

				var svg = d3.select("body").append("svg")
					.attr("width", "100%")
					.attr("height", "100%")
					.call(d3.zoom().on("zoom", on_zoom))
					.append("g");

				var simulation = d3.forceSimulation();

				d3.json(dataset_name, function (error, graph) {
					if (error) throw error;

					var minX = 0, minY = 0, maxX = 0, maxY = 0;
					var scale = 1;
					var nodes = {};

					graph.nodes.forEach(function (n) {
						nodes[n.id] = n;
						n.y = -n.y;
						if (n.x < minX) minX = n.x;
						if (n.y < minY) minY = n.y;
						if (n.x > maxX) maxX = n.x;
						if (n.y > maxY) maxY = n.y;
					});

					graph.nodes.forEach(function (n) {
					 	scale = Math.min(1024 / (maxX - minX), 1024 / (maxY - minY));
						n.x = (n.x - minX) * scale;
						n.y = (n.y - minY) * scale;
					});

					graph.edges.forEach(function (l) {
						l.source = nodes[l.source];
						l.target = nodes[l.target];
					});

					var link = svg.append("g")
						.attr("class", "links")
						.selectAll(".link")
						.data(graph.edges)
						.enter()
						.append("line")
						.attr("class", "link")
						//.attr("stroke-width", function (l) { return l.size * scale / 2; })
						.attr("x1", function (l) { return l.source.x; })
						.attr("y1", function (l) { return l.source.y; })
						.attr("x2", function (l) { return l.target.x; })
						.attr("y2", function (l) { return l.target.y; })

					var node = svg.append("g")
						.attr("class", "nodes")
						.selectAll(".node")
						.data(graph.nodes)
						.enter()
						.append("circle")
						.attr("class", "node")
						.attr("r", function (n) { return n.size * scale / 2; })
						.attr("fill", function (n) { return n.color; })
						.attr("cx", function (n) { return n.x; })
						.attr("cy", function (n) { return n.y; })
						.attr("id", function (n) { return "node-" + n.id; })
						.call(d3.drag()
							.on("start", on_drag_start)
							.on("drag", on_drag)
							.on("end", on_drag_end))
						.on("click", on_node_click)
						.on("mouseover", on_node_mouseenter)
						.on("mouseout", on_node_mouseexit);

					node.append("title").text(function (d) { return d.label; });

					simulation.force("x", d3.forceX(function (n) { return n.x; }).strength(0.8));
					simulation.force("y", d3.forceY(function (n) { return n.y; }).strength(0.8));

					/*
					simulation.force("link", d3.forceLink().id(function(d) { return d.id; }).strength(0.1));
					simulation.force("link").links(graph.links);
					*/

					simulation.nodes(graph.nodes).on("tick", on_tick);

					function on_tick() {
						link
			        .attr("x1", function(d) { return d.source.x; })
			        .attr("y1", function(d) { return d.source.y; })
			        .attr("x2", function(d) { return d.target.x; })
			        .attr("y2", function(d) { return d.target.y; });

		    		node
			        .attr("cx", function(d) { return d.x; })
			        .attr("cy", function(d) { return d.y; });
					}
				});

				function on_zoom() {
					svg.attr("transform", d3.event.transform);
				}

				function on_drag_start(d) {
					if (!d3.event.active) simulation.alphaTarget(0.3).restart();
					d.fx = d.x;
					d.fy = d.y;
				}

				function on_drag(d) {
					d.fx = d3.event.x;
					d.fy = d3.event.y;
				}

				function on_drag_end(d) {
					if (!d3.event.active) simulation.alphaTarget(0);
					d.fx = null;
					d.fy = null;
				}

				var selectedNode = undefined;

				function on_node_click(n) {
					selectedNode = n;
					highlight_node(selectedNode);
				}

				function on_node_mouseenter(n) {
					highlight_node(n);
				}

				function on_node_mouseexit(n) {
					highlight_node(selectedNode);
				}

				function highlight_node(n) {
					d3.selectAll(".node").classed("active", function (x) { return n === x; });
					d3.selectAll(".link").classed("active", function (x) { return x.source === n || x.target === n; });
				}
			}

			main();
		</script>
	</body>
</html>
